# DAY 3 : (2017.01.11)

## I. OPERATING SYSTEM(운영체제)
### 1. OS에 대한 기초
**OS의 존재 이유**  
: OS가 존재하지 않았을 떄는, 각 사용자의 목적에 따라 하드웨어를 제어하는 프로그램을 개발해야 했다.  
그리하여 운영체제가 하드웨어의 공통적인 제어 방식을 구현하여 사용자는 자기 목적에 맞는 프로그램만 개발하면 된다. 

**운영체제의 종류**  
1. UNIX 체계  
2. LINUX 체계  ->  Linux와 UNIX를 포함하여 UNIX-like OS로 정의   
3. Windows 체계  

**운영체제가 하는 일**  
1. 시스템 하드웨어 관리  
- 사용자의 프로그램의 오류나 잘못된 자원 사용을 감시  
- 입출력 장치 등의 자원에 대한 연산과 제어를 관리  
2. (가상)시스템 서비스 제공  
- 사용자에게 프로그램을 쉽고 효율적으로 실행할 수 있는 환경 제공  
3. ```지원관리```  
- 시스템 하드훼어 및 소프트웨어 자원을 여러 사용자 간에 효율적 할당, 관리, 보호

### 2. 프로세스
**프로세스**  
보조기억장치 -> 주기억장치 -> CPU  
게임 내 'loading': 보조기억장치에 존재하는 0과 1을 불러오는 과정  
프로그램이 보조기억장치에서 주기억장치로 이동하면 '프로세스'가 된다.

**프로세스 상태**
프로세스 생성 -> 준비 -> 실행 -> 대기 -> 준비 -> 실행 -> 종료  
준비 과정: CPU는 한 가지 일만 동시에 할 수 있기 때문에, OS는 나머지 프로세스는 준비 상태로 두고 한 개의 프로세스가 끝나면 다음 프로세스를 CPU로 보내준다. 

**프로세스 처리 방식**  
1. FCFS(First-Come First-Served)  
2. SJF(Shortest Job First)  
1) 실행 시간이 가장 짧은 프로세스에게 먼저 CPU할당  
2) 평균 대기시간이 가장 적은 알고리즘  
3) 실행 시간이 긴 프로세스는 무한 대기할 가능성  
3. Round Robin Scheduling  
1) 각 프로세스를 시간 할당량 동안만 실행  
2) 완료되지 않은면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치  
3) 할당 시간이 클수록 FCFS와 비슷해진다  
4) 할당시간이 적을 수록 문맥교환으로 오버헤드 발생  
4. Priority Based Scheduling  
1) 프로세스마다 우선순위 부여  
2) 가장 낮은 순위를 부여받은 프로세스의 무한 연기 발생 가능  
5. Multi Queue Scheduling  
1) 프로세스를 특정 그룹으로 분류하고 각각의 준비상태 큐 마다 다른 스케줄링 기법 사용 가능

**주기억장치 관리**  
1) 단순 관리  
2) 가상 메모리  
주기억장치에서 실행해야 될 프로세스 일부를 보조기억장치에 넘겨, 보조기억장치의 일부를 주기억장치처럼 쓰는 방식

### 3. 파일 
**파일 관리**
응용 프로그램 <-> 운영체제 <-> 보조기억장치  
: 보조기억장치에 폴더나 파일은 개별 공간이 존재하는 것이 아닌 주소에 태그가 달리는 형식으로 저장된다. 

**파일 시스템**  
운영체제마다 파일을 저장하고 불러오는 방식이 다름  


cf. 맥에서 조각모음이 없는 이유

cf. SSD에서 조각모음을 할 필요없는 이유

### 4. 커널
Kernel은 운영체제의 척추이자 핵심
커널의 역할: 하드웨어와 직접적인 소통하는 기관

### 5. 멀티태스킹
1) 싱글코어 멀티테스킹  
2) 멀티코어 멀티테스킹

## II. 자료구조

### 1. 자료구조의 정의
자료를 효율적으로 정리하고 해결하는 방법

예) 적절한 모양의 블럭(자류구조)을 요리조리 돌리고 옮겨(알고리즘)서 게임을 클리어
효율적으로 물건들의 부피를 줄이고(자료구조) 꺼낼 순서에 맞게(알고리즘)을 차곡차곡 정리해 넣으면 알차게!

### 2. 자료구조의 종류
**1. 원시 구조**

**2. 선형 구조**  
메모리 안에 순서대로 배열
메모리를 신발장으로 생각

1) 배열  
- 학교에서 1번부터 30번까지 신발을 넣고 뺄 수 있음  
- 배열의 경우는 메모리에 30번까지 메모릴 쓴다고 정의하면, 추후에 늘릴 수가 없음  
- 크기가 정해져 있기 때문에, 데이터가 어느 위치에 저장되어 있는지 쉽게 파악 -> 속도가 빠름  
- 삽입/삭제 등이 자유롭지 않음  

2) 연결 리스트  
단순 연결 리스트  
- 삽입/삭제가 용이함  
- 계속 물어봐야 하기 때문에 속도가 느림  
- 앞에 위치한 데이터의 주소를 모름  

3) 이중 연결 리스트
역추적이 가능함 

4) 원형 연결 리스트  

스택(Stack)
활용 예시: 뒤로가기 버튼, 최근 문서가 마지막으로 표현
Last-in First-out 방식
push & pop

큐(Queue)  
= 작업 대기열이라는 뜻   
활용예시: 작업대기열에 많이 사용   
First-in First-out 방식
put & get

덱(Dequeue)  
: 자료의 앞과 뒤에서 빼는 방식  
= Double-ended queue  

**3. 비선형 구조**  
트리(Tree)  
활용 예시: Finder, 탐색기 등  
검색에 매우 용이함

그래프(Graph)  
대규모 관계를 표현하기 위해 자주 사용  
예시) 페이스북의 관계도 등
  
**4. 물리적 구조**  
**5. 추상적 구조**  

## III. 알고리즘
### 1. 알고리즘의 정의
1) 문제해결을 위한 절차/방법  
2) 어떠한 문제를 해결하기 위한 여러 동작들의 모음  
3) 대표적 알고리즘: 정렬, 탐색, 재귀 등

### 2. 정렬 알고리즘
가지고 있는 데이터에 따라 다른 알고리즘을 사용해야지 효과적이다.  
최선의 방법은 있어도 항상 맞는 방법은 없다. 

**1) 선택정렬**  
전체를 읽고 가장 작은 것을 첫번째 자리에 놓고, 천 번째를 제외한 나머지를 다시 읽고 가장 작은 것을 두번째 자리에 표시
시간복잡도: O(n^2)  

**2) 버블정렬**  
옆에 것이랑 비교하여 가장 큰 것을 하나씩 밀어서 정리
시간복잡도: O(n^2)  

**3) 삽입정렬**  
시간복잡도: O(n^2)  

**1) 병합정렬**  
구간을 나눠서 정렬한 다음 서로 합쳐서 다시 정렬하는 방식    
시간복잡도: O(nlogn)  

**1) 퀵 정렬**  
중간지점을 찾아서 나누고, 다시 중간지점을 찾아서 나누고 하여 정렬하는 방식  
평균적으로 가장 좋은 성능을 가지기 때문에 퀵정렬이라고 부름  
한계점: 기준점을 잘 못 잡으면 성능이 급격하게 떨어짐  
시간복잡도: O(n^2)  

### 3. 시간 복잡도
알고리즘이 실행되는데 소요되는 시간분석  
선택정렬: n(n + 1) / 2
-> n^2이 가장 큰 변수로 작용하기 때문에 시간복잡도를 표시하는 역할을 함

시간 복잡도를 표기할 때 일반적으로 빅오표기방법을 사용
빅오(Big-oh): 최악의 경우를 표기하는 방법

cf. 선형 탐색 : 0(n)
이진 탐색 : O(logn)




 
 





 
